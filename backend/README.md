# Backend

## Запуск

Для локального поднимите базу данных, отредактируйте `./deploy/config.yml` и выполните:

```shell
# Переключаемся на требуемую версию NodeJS и npm
nvm use

# Устанавливаем необходимые зависимости
yarn global add @nestjs/cli
yarn install

# Собираем проект
yarn build

# Запускаем приложение
yarn start
```

В проекте описана сборка с использованием Docker и docker-compose. Для ее использования выполните:

```shell
docker-compose up --build -d
```

## Использование API

```shell
curl -X POST --location 'http://localhost:3000/api/users/' \
--header 'Content-Type: application/json' \
--data-raw '{
    "email": "meetmorrowsolonmars@gmail.com",
    "username": "meetmorrowsolonmars",
    "hashedPassword": "password_hash",
    "fullName": "Denisenko Maxim Vyacheslavovich"
}'

curl --location 'http://localhost:3000/api/users/meetmorrowsolonmars@gmail.com'
```

## Обзор

```
├── src
│   ├── api
│   │   └── http
│   │       ├── controllers
│   │       └── schemas
│   ├── application
│   │   ├── repositories
│   │   │   ├── implementations
│   │   │   └── interfaces
│   │   └─── services
│   │       ├── implementations
│   │       └── interfaces
│   ├── domain
│   │   └── entities
│   ├── infrastructure
│   │   ├── logging
│   │   └── storages
│   │       ├── implementations
│   │       ├── interfaces
│   │       └── models
│   ├── app.module.ts
│   └── main.ts
├── README.md
├── package-lock.json
├── package.json
└── tsconfig.json
```

## Директории

### `/src`

Основная директория для исходного кода проекта.

### `/src/main.ts`

В данном файле обычно находится точка входа в приложение. Иногда в приложении необходимо создавать несколько различных
точек входа для различных кейсов использования. Например, код, запускающий определенную CronJob, может быть размещен
отдельно и независимо от кода веб-приложения. Также можно разместить CLI-утилиты, способствующие сопровождению и
обслуживанию основного приложения. В данном случае, если требуются разные точки входа, рекомендуется выделить отдельную
директорию `/src/cmd`, внутри которой разместить код различных точек входа и инициализации приложений.

* `/src/cmd/web/main.ts` – точка входа для запуска веб-приложения.
* `/src/cmd/moving_data_to_archive_cronjob/main.ts` – точка входа в cron job, перемещающий данные в архив.
* `...`

### `/src/api`

Директория, включающая файлы, связанные с API. В её состав входят описания контроллеров и схем запросов. Здесь может
находиться не только описание различных протоколов взаимодействия, таких как OpenAPI/Swagger, JSON, GRPC,
но и контракты сообщений для Kafka топиков.

### `/src/api/http`

Директория, включающая файлы, связанные с HTTP API. Здесь находятся контроллеры (`controllers`), ответственные за
обработку запросов от клиентов, а также описания запросов и ответов, используемых в API.

#### Замечание

Если рассматривать приложение как сервер, реализующий HTTP API, то контроллеры можно переместить в директорию
`application`. Это предложение основывается на разделении логики приложения и логики домена.

Представим, что мы разрабатываем сервер, предоставляющий API для наложения фильтров на изображения.
У нас есть правила, ограничивающие количество применений фильтров для каждого пользователя. Эти правила являются
частью логики приложения. Реализации алгоритмов и фильтров уже включают в себя уровень логики домена. Такая логика
должна быть размещена в директории domain, поскольку её можно в любой момент извлечь для создания CLI-утилиты или
десктопного приложения. В данном примере, смешивая эти правила, мы усложняем возможное разделение на несколько
отдельных приложений.

### `/src/application`

Директория содержит файлы, относящиеся к слою приложения.

### `/src/application/repositories`

В этой директории размещаются репозитории, ответственные за взаимодействие с данными. Этот слой должен включать в
себя правила преобразования бизнес-сущностей в сущности уровня хранилища. Приведу несколько примеров.

* Сервис для поиска путей:
    * Уровень бизнес-логики: двунаправленный граф.
    * Уровень хранилища: матрица расстояний.
* Сервис работы с бинарным деревом поиска:
    * Уровень бизнес-логики: бинарное дерево поиска в виде связанных узлов на указателях.
    * Уровень хранилища: плоское представление в виде строки с вложенными
      скобками (`(8 (3 (1) (6 (4) (7))) (10 (14 (13))))`).

Соответствующие интерфейсы, определяющие контракты для репозиториев, находятся в директории `interfaces`. В директории
`implementations` содержатся конкретные реализации.

Слой может обрабатывать ошибки уровня инфраструктуры и преобразовывать их в ошибки уровня бизнес-логики.

### `/src/application/services`

В этой директории можно разместить сервисы, описывающие бизнес-логику приложения. Рекомендуется разделить их на
интерфейсы и реализацию для достижения лучшей структурированности проекта.

Этот слой взаимодействует исключительно с бизнес-сущностями (`/src/domain/entities`). Следовательно, он принимает их
на вход, и передает их в репозитории. Код этого уровня организован примерно следующим
образом: `controllers -> SERVICE -> repositories -> storage -> (database|file system|cloud storage)`.

Слой поднимает и обрабатывает только ошибки уровня бизнес-логики. Ошибки уровня инфраструктуры, которые не преобразованы
в ошибки бизнес-логики, должны либо пропускаться этим слоем, либо обрабатываться как общие ошибки без привязки к
конкретным типам.

**P.S.:** Также существует подход, согласно которому на этом уровне описывается конкретный бизнес-функционал, а
сценарии, состоящие из нескольких функций, описываются в use case. Например:

* **Сервис взаимодействия с учетными записями пользователей:**
    * Определяет логику поиска пользователей.
* **Сервис взаимодействия с ролями пользователей:**
    * Определяет логику получения списка ролей пользователей.
    * Определяет логику проверки возможности редактирования данных у пользователя с заданным списком ролей.
* **Use case описывает операцию редактирования ролей пользователей админом:**
    * Ищет учетную запись админа.
    * Получает список ролей админа.
    * Проверяет, есть ли у администратора возможность редактировать список ролей.
    * Ищет учетную запись обычного пользователя.
    * Получает список ролей обычного пользователя.
    * Изменяет список ролей обычного пользователя и сохраняет изменения.

### `/domain`

Здесь размещаются файлы, связанные с бизнес-логикой домена. Это общие элементы, не зависящие от того, где приложение
запущено или какой инфраструктурой оно оперирует.

### `/domain/entities`

В этой директории могут располагаться сущности, представляющие бизнес-объекты. Описание сущностей может включать в себя
примитивные типы, пользовательские типы того же уровня, а также некоторые специфичные библиотечные типы, например,
представление графа. Главное, чтобы типы из библиотек логически соответствовали тому же домену, что и сущности.

### `/infrastructure`

Здесь располагаются файлы, связанные с инфраструктурными задачами. В этой директории я бы разместил код:

* настройки логирования,
* инициализации и работы с метриками,
* работы с хранилищами данных,
* различное программное обеспечение,
* парсинг файлов настройки.

### `/infrastructure/storages`

В этой директории находится код, описывающий взаимодействие с конкретными хранилищами данных. Здесь располагается код
записи и считывания данных из хранилища. Рассмотрим код, который должен находиться в этом слое на примере работы с
бинарными деревьями поиска. В таком сервисе бизнес-логика отвечает за построение графа. Слой репозиториев отвечает за
преобразование графа в скобочное представление, а слой хранилища занимается сохранением этого представления в одном из
хранилищ, будь то реляционная база данных или файловое хранилище (и тд.).

Слой разделен на интерфейсы (`interfaces`), реализацию (`implementations`), и модели данных (`models`), которые будут
удобны для взаимодействия с хранилищем. Также здесь мы должны обрабатывать ошибки от инфраструктуры, такие как
дублирование записей с уникальным ключом, перемещение данных из одной партиции в другую и тд.

**P.S.:** На практике можно иногда пренебрегать подобным слоем, если ваши структуры данных достаточно просты и не
требуют специфичного преобразования на уровне репозиториев. В таком случае логику работы с хранилищем можно разместить в
слое репозиториев, что обеспечит приемлемое разделение на слои.

Однако, если появляется необходимость добавить кеширование на уровне сервера, я бы предпочел структуру проекта с
отдельными репозиториями, где размещен кеш, и отдельно логикой работы с хранилищем на уровне стораджа.

### `/infrastructure/logging`

Может содержать код настройки системы логирования.
Может содержать код настройки системы логирования.